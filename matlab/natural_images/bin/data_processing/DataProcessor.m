classdef DataProcessor < handle
    %DATAPROCESSOR Methods to get data batches and PCA transforms
    % The PCA transform is stored in a .mat file after calculation to avoid
    % expensive recalulcation with reproducability issues.
    %
    % The data is generated by sampling image patches from the larger
    % natural scene images. N samples are collected, transformed to PCA
    % space using the saved transform and stored in Z. From this large batch
    % smaller batches can be extracted (see getPCAdataBatch).
    % If desired, a new main batch Z can be sampled (see generatePCAdata)
    % NOTE: This framework is overly complicated and likely not necessary
    % but was written in an attempt to be as general as possible.

    properties
		dataset 		% Name of the dataset
		dim 		    % Dimension of the data, usually dim = winsize^2
		winsize 		% if square images are used this is the image width/height
		N				% Number of data points load into RAM at a time
		modelLayer 		% The the layer number of in the neural network
		rDim			% The number of retained dimensions after PCA transform
		rngseed 		% random seed for reproducibility
		pcaDirname 		% name of directory to store PCA data (e.g. whitening matrix)
		Z				% variable to store data loaded into RAM
		dataFun			% Function handle used to sample data Z
		isDisabled		% if true no PCA transform is used
	end

	properties (Hidden = true)
		bNr				% Used to keep track of batches taken from Z
        pcaFileName     % The name of the PCA data file
	end

    methods
		function obj = DataProcessor(init)
			% DATAPROCESSOR init = {dataset, D, N, modelLayer, rDim, rngseed, pcaDirname, dataFun}
			if nargin == 0
			;
			elseif isa(init, 'cell')
				obj.dataset = init{1};
				obj.dim = init{2};
				obj.syncDwinsize();
				obj.N = init{3};
				obj.modelLayer = init{4};
				if length(init) < 5, obj.rDim = []; else, obj.rDim = init{5};end
				if length(init) < 6 || isempty(init{6})
					obj.rngseed = 'shuffle';
				else
					obj.rngseed = init{6};
				end
				if length(init) < 7, obj.pcaDirname = []; else, obj.pcaDirname = init{7};end
				if length(init) < 8, obj.dataFun = []; else, obj.dataFun = init{8};end
				rng(obj.rngseed);
			end
			if isempty(obj.pcaDirname)
				obj.generateDirname();
            else
                obj.pcaFileName = fullfile(obj.pcaDirname, 'transform.mat');
			end
			obj.bNr = 1; % number for sampling mini-batches
			obj.isDisabled = false; % if true the PCA transform is replaced with an identity
		end

		function dataHandle = getPCAdataBatch(obj, batchSize)
			%getPCAdataBatch Help function to load dim reduced image data.
			dataHandle = DataHandle();
			
			% if not stored main batch, generate new
			if isempty(obj.Z)
				obj.generatePCAdata();
			end
			
			% if the whole main batch is used at once, return main batch and clear to save memory
			if batchSize == obj.N
				fprintf('(Note: batchSize == obj.N)\n')
				dataHandle.X = obj.Z;
				obj.clearZ();
				return
			end
			
			% if not enough data in main batch, generate a new
			if obj.N > size(obj.Z, 1)
				warning('Not enough pregenerated PCAdata. Generating new data.')
				obj.generatePCAdata();
			end

			% Extract mini-batch from main batch
			st = batchSize * (obj.bNr - 1) + 1;
			en =  batchSize * obj.bNr;
			dataHandle.X = obj.Z(st:en,:);
			obj.bNr = mod(obj.bNr, floor(obj.N/batchSize)) + 1;
		end

		function generatePCAdata(obj, epoch)
			%generatePCAdata Generate a main batch using datafun, whitening and dewhitening matrices

			obj.syncDwinsize() % for compatibility with old version
			if nargin > 1, rng(obj.rngseed + epoch); else, rng(obj.rngseed); end
			batchSize = min(50000, obj.N);
			nBatches = ceil(obj.N / batchSize);
			
			% if no PCA matrices are available, generate them
			if isempty(obj.pcaDirname) || ~isfile(obj.pcaFileName)
				warning('No PCA data nor transform available.')
				fprintf('A PCA transform file is needed to generate the PCA data.\n');
				answer = input('Would you like to generate a PCA transform file? ', 's');
				if ~ (strcmpi(answer, 'y') || strcmpi(answer, 'yes'))
					error('No PCA data nor transform available.')
				end
				obj.generatePCAtransform(batchSize, 2*nBatches);
			end
			
			% Generate the data in batches
			obj.Z = zeros(obj.N, obj.rDim);
			b = 1;
			e = batchSize;
			for i = 1:nBatches
				fprintf('Getting batch %d/%d\n', i, nBatches)
				z = obj.dataFun(batchSize, i);
				% Remove DC-component and whiten
				obj.Z(b:e, :) = obj.toPCA(z);
				b = b + batchSize;	e = e + batchSize;
			end
			obj.Z = obj.Z(randperm(size(obj.Z,1)),:); % Shuffle the data
			obj.bNr = 1; % reset batch count
		end

		function generatePCAtransform(obj, batchSize, nBatches)
			%GENERATEPCADATA Generate whitening and dewhitening matrices and saves in .mat file
			%   batchSize and nBatches are used for batch calculation of covariance matrix
			obj.clearZ();
			obj.syncDwinsize()
			rng(obj.rngseed)
			if isempty(obj.dataFun)
				obj.dataFun = @(bSize, bNr) getRawData(obj.dataset, obj.winsize, bSize, bNr);
			end
			% calculation of sample mean and covariance matrix using batches
			[xmean, C] = covOnline(obj.dataFun, obj.dim, batchSize, nBatches);

			[E, D] = eig(C);
			[d, order] = sort(diag(D), 'descend');
			E = E(:, order);
			totVar = sum(d);
			disVar = (totVar - cumsum(d))./totVar;

			if isempty(obj.rDim)
				%figure('units','normalized','outerposition',[0 0 1 1]);
				figure
				semilogy(1:obj.dim, disVar, '.-')
				grid on
				obj.rDim = input('Number of retained pca dimensions: ');
			end
			retVar 	= 1 - disVar(obj.rDim); % Saved to disk
			D 		= diag(d(1:obj.rDim).^-0.5);
			Wh 		= E(:, 1:obj.rDim) * D; % Saved to disk
			deWh 	= D^(-1) * E(:, 1:obj.rDim)'; % Saved to disk

			if isempty(obj.pcaDirname)
				obj.generateDirname();
			end
			mkdir(obj.pcaDirname);

			if isfile(obj.pcaFileName)
				answer = input(sprintf('%s already exists, do you want to overwrite the existing file? ',...
					obj.pcaFileName ), 's');
				if ~(strcmpi(answer(1), 'y'))
					fprintf('Not replacing existing file.\n')
					return
				end
				fprintf('Replacing existing file.\n')
			end

			dataFuntmp = obj.dataFun; % temp removal of dataFun for saving space when saving
			obj.dataFun = [];
			save(obj.pcaFileName, 'xmean', 'Wh', 'deWh', 'd', 'retVar', 'obj', '-v7.3')
			obj.dataFun = dataFuntmp;
		end

		function Z = clearZ(obj)
			%CLEARZ Clears memory of large matrix Z. Returns Z if temporary save is necessary
			Z = obj.Z;
			obj.Z = [];
		end
		
		function clearDataFun(obj)
			obj.dataFun = [];
		end
		
		function Z = toPCA(obj, z, b)
			% toPCA Subtracts b from z and transforms to PCA space
			if nargin < 3, b = mean(z,2); end
			Z = bsxfun(@minus, z, b) * obj.getWh(obj.rDim);
		end

		function Wh = getWh(obj, rDim)
			%GETWH Get the whitening matrix associated with this DataProcessor.
			% 	The whitening matrix is stored in obj.pcaFileName
			% 	If DataProcessor is disabled return a identity matrix instead
			m = matfile(obj.pcaFileName);
			if isempty(obj.isDisabled) || ~obj.isDisabled
				if nargin < 2
					Wh = m.Wh;
				else
					Wh = m.Wh(:, 1:rDim);
				end
			else
				Wh = eye(size(m.Wh, 1));
			end
		end

		function deWh = getdeWh(obj, rDim)
			%GETDEWH Get the dewhitening matrix associated with this DataProcessor.
			% 	The dewhitening matrix is stored in obj.pcaFileName
			% 	If DataProcessor is disabled return a identity matrix instead
			m = matfile(obj.pcaFileName);
			if isempty(obj.isDisabled) || ~obj.isDisabled
				if nargin < 2
					deWh = m.deWh;
				else
					deWh = m.deWh(1:rDim, :);
				end
			else
				deWh = eye(size(m.deWh, 1));
			end
		end

		function xMean = getSampleMean(obj)
			%GETSAMPLEMEAN Returns the sample mean stored in obj.pcaFileName
			m = matfile(obj.pcaFileName);
			xMean = m.xmean;
		end

		function generateDirname(obj)
			% generateDirname generates a directory name for saving PCA matrices.
			%	If no rDim is set generatePCAtransform is run
            global CNCE_IMAGE_DATA_FOLDER
			if isempty(obj.rDim)
				warning('Number of retained dimensions not specified.')
				fprintf(['The number of retained dimensions needs to be specified ',...
					'to create the folder name.\n']);
				fprintf(['By running generatePCAtransform() you are able to choose ',...
					'the number of retained dimensions from a plot.\n']);
				answer = input('Would you like to run generatePCAtransform() now? ', 's');
				if ~ (strcmpi(answer, 'y') || strcmpi(answer, 'yes'))
					error('Number of retained dimensions not specified.')
				end
				batchSize = min(50000, obj.N);
				nBatches = ceil(obj.N / batchSize);
				obj.generatePCAtransform(batchSize, 2*nBatches);
			end
			obj.pcaDirname = [CNCE_IMAGE_DATA_FOLDER, '/pca_data/', obj.dataset, ...
				'/layer', num2str(obj.modelLayer), '_rDim', num2str(obj.rDim)];
            obj.pcaFileName = fullfile(obj.pcaDirname, 'transform.mat');
		end

		function syncDwinsize(obj)
			%syncDwinsize Fixes compatibility issue between D and winsize
			if isempty(obj.dim) && isempty(obj.winsize)
				error('Neither D nor winsize available!')
			elseif isempty(obj.dim)
				obj.dim = obj.winsize^2;
			elseif isempty(obj.winsize)
				obj.winsize = sqrt(obj.dim);
			else
				;
			end
		end
    end
end

